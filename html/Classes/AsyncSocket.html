<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<title>AsyncSocket Class Reference</title>

	<link rel="stylesheet" href="../css/style.css">
	<meta name="viewport" content="initial-scale=1, maximum-scale=1.4">
	<meta name="generator" content="appledoc 2.2.1 (build 1334)">
</head>
<body class="appledoc">
	<header>
		<div class="container" class="hide-in-xcode">
			
			<h1 id="library-title">
				<a href="../index.html">AWARE Client iOS </a>
			</h1>

			<p id="developer-home">
				<a href="../index.html">AWARE</a>
			</p>
			
		</div>
	</header>

	<aside>
		<div class="container">
			<nav>
				<ul id="header-buttons" role="toolbar">
					<li><a href="../index.html">Index</a></li>
<li><a href="../hierarchy.html">Hierarchy</a></li>

					<li id="on-this-page" role="navigation">
						<label>
							On This Page

							<div class="chevron">
								<div class="chevy chevron-left"></div>
								<div class="chevy chevron-right"></div>
							</div>

							<select id="jump-to">
	<option value="top">Jump To&#133;</option>
	

	
	
	<option value="tasks">Tasks</option>
	
	

	
	

	

	
	<optgroup label="Instance Methods">
		
		<option value="//api/name/acceptOnInterface:port:error:">- acceptOnInterface:port:error:</option>
		
		<option value="//api/name/acceptOnPort:error:">- acceptOnPort:error:</option>
		
		<option value="//api/name/attachSocketsToRunLoop:error:">- attachSocketsToRunLoop:error:</option>
		
		<option value="//api/name/canAcceptBytes">- canAcceptBytes</option>
		
		<option value="//api/name/close">- close</option>
		
		<option value="//api/name/configureSocketAndReturnError:">- configureSocketAndReturnError:</option>
		
		<option value="//api/name/configureStreamsAndReturnError:">- configureStreamsAndReturnError:</option>
		
		<option value="//api/name/connectToAddress:error:">- connectToAddress:error:</option>
		
		<option value="//api/name/connectToAddress:viaInterfaceAddress:withTimeout:error:">- connectToAddress:viaInterfaceAddress:withTimeout:error:</option>
		
		<option value="//api/name/connectToAddress:withTimeout:error:">- connectToAddress:withTimeout:error:</option>
		
		<option value="//api/name/connectToHost:onPort:error:">- connectToHost:onPort:error:</option>
		
		<option value="//api/name/connectToHost:onPort:withTimeout:error:">- connectToHost:onPort:withTimeout:error:</option>
		
		<option value="//api/name/connectedAddress">- connectedAddress</option>
		
		<option value="//api/name/connectedHost">- connectedHost</option>
		
		<option value="//api/name/createStreamsFromNative:error:">- createStreamsFromNative:error:</option>
		
		<option value="//api/name/createStreamsToHost:onPort:error:">- createStreamsToHost:onPort:error:</option>
		
		<option value="//api/name/delegate">- delegate</option>
		
		<option value="//api/name/disconnect">- disconnect</option>
		
		<option value="//api/name/disconnectAfterReading">- disconnectAfterReading</option>
		
		<option value="//api/name/disconnectAfterReadingAndWriting">- disconnectAfterReadingAndWriting</option>
		
		<option value="//api/name/disconnectAfterWriting">- disconnectAfterWriting</option>
		
		<option value="//api/name/doAcceptFromSocket:withNewNativeSocket:">- doAcceptFromSocket:withNewNativeSocket:</option>
		
		<option value="//api/name/doBytesAvailable">- doBytesAvailable</option>
		
		<option value="//api/name/doSocketOpen:withCFSocketError:">- doSocketOpen:withCFSocketError:</option>
		
		<option value="//api/name/doStreamOpen">- doStreamOpen</option>
		
		<option value="//api/name/enablePreBuffering">- enablePreBuffering</option>
		
		<option value="//api/name/getAbortError">- getAbortError</option>
		
		<option value="//api/name/getConnectTimeoutError">- getConnectTimeoutError</option>
		
		<option value="//api/name/getErrnoError">- getErrnoError</option>
		
		<option value="//api/name/getReadMaxedOutError">- getReadMaxedOutError</option>
		
		<option value="//api/name/getReadTimeoutError">- getReadTimeoutError</option>
		
		<option value="//api/name/getSocketError">- getSocketError</option>
		
		<option value="//api/name/getWriteTimeoutError">- getWriteTimeoutError</option>
		
		<option value="//api/name/hasBytesAvailable">- hasBytesAvailable</option>
		
		<option value="//api/name/isIPv4">- isIPv4</option>
		
		<option value="//api/name/maybeDequeueRead">- maybeDequeueRead</option>
		
		<option value="//api/name/maybeDequeueWrite">- maybeDequeueWrite</option>
		
		<option value="//api/name/maybeScheduleDisconnect">- maybeScheduleDisconnect</option>
		
		<option value="//api/name/moveToRunLoop:">- moveToRunLoop:</option>
		
		<option value="//api/name/newAcceptSocketForAddress:error:">- newAcceptSocketForAddress:error:</option>
		
		<option value="//api/name/progressOfReadReturningTag:bytesDone:total:">- progressOfReadReturningTag:bytesDone:total:</option>
		
		<option value="//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:">- readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</option>
		
		<option value="//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:">- readDataToData:withTimeout:buffer:bufferOffset:tag:</option>
		
		<option value="//api/name/readDataToData:withTimeout:maxLength:tag:">- readDataToData:withTimeout:maxLength:tag:</option>
		
		<option value="//api/name/readDataToData:withTimeout:tag:">- readDataToData:withTimeout:tag:</option>
		
		<option value="//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:">- readDataToLength:withTimeout:buffer:bufferOffset:tag:</option>
		
		<option value="//api/name/readDataToLength:withTimeout:tag:">- readDataToLength:withTimeout:tag:</option>
		
		<option value="//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:">- readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</option>
		
		<option value="//api/name/readDataWithTimeout:buffer:bufferOffset:tag:">- readDataWithTimeout:buffer:bufferOffset:tag:</option>
		
		<option value="//api/name/readDataWithTimeout:tag:">- readDataWithTimeout:tag:</option>
		
		<option value="//api/name/readIntoBuffer:maxLength:">- readIntoBuffer:maxLength:</option>
		
		<option value="//api/name/runLoopModes">- runLoopModes</option>
		
		<option value="//api/name/scheduleDequeueRead">- scheduleDequeueRead</option>
		
		<option value="//api/name/setRunLoopModes:">- setRunLoopModes:</option>
		
		<option value="//api/name/startTLS:">- startTLS:</option>
		
		<option value="//api/name/unreadData">- unreadData</option>
		
		<option value="//api/name/writeData:withTimeout:tag:">- writeData:withTimeout:tag:</option>
		
	</optgroup>
	
	
</select>
						</label>
					</li>
				</ul>
			</nav>
		</div>
	</aside>

	<article>
		<div id="overview_contents" class="container">
			<div id="content">
				<main role="main">
					<h1 class="title">AsyncSocket Class Reference</h1>

					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<th>Inherits from</th>
	<td>NSObject</td>
</tr><tr>
	<th>Declared in</th>
	<td>AsyncSocket.h<br />AsyncSocket.m</td>
</tr>
						</tbody></table></div>
					

                    

					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						

						
						<h2 class="task-title">Other Methods</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/delegate" title="delegate"></a>
	<h3 class="method-title"><code><a href="#//api/name/delegate">&ndash;&nbsp;delegate</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Use &ldquo;canSafelySetDelegate&rdquo; to see if there is any pending business (reads and writes) with the current delegate
before changing it.  It is, of course, safe to change the delegate before connecting or accepting connections.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (id)delegate</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Use &ldquo;canSafelySetDelegate&rdquo; to see if there is any pending business (reads and writes) with the current delegate
before changing it.  It is, of course, safe to change the delegate before connecting or accepting connections.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/acceptOnPort:error:" title="acceptOnPort:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/acceptOnPort:error:">&ndash;&nbsp;acceptOnPort:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Tells the socket to begin listening and accepting connections on the given port.
When a connection comes in, the AsyncSocket instance will call the various <a href="#//api/name/delegate">delegate</a> methods (see above).
The socket will listen on all available interfaces (e.g. wifi, ethernet, etc)</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)acceptOnPort:(UInt16)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Tells the socket to begin listening and accepting connections on the given port.
When a connection comes in, the AsyncSocket instance will call the various <a href="#//api/name/delegate">delegate</a> methods (see above).
The socket will listen on all available interfaces (e.g. wifi, ethernet, etc)</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/acceptOnInterface:port:error:" title="acceptOnInterface:port:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/acceptOnInterface:port:error:">&ndash;&nbsp;acceptOnInterface:port:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method is the same as <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> with the additional option
of specifying which interface to listen on. So, for example, if you were writing code for a server that
has multiple IP addresses, you could specify which address you wanted to listen on.  Or you could use it
to specify that the socket should only accept connections over ethernet, and not other interfaces such as wifi.
You may also use the special strings &ldquo;localhost&rdquo; or &ldquo;loopback&rdquo; to specify that
the socket only accept connections from the local machine.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)acceptOnInterface:(NSString *)<em>interface</em> port:(UInt16)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method is the same as <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> with the additional option
of specifying which interface to listen on. So, for example, if you were writing code for a server that
has multiple IP addresses, you could specify which address you wanted to listen on.  Or you could use it
to specify that the socket should only accept connections over ethernet, and not other interfaces such as wifi.
You may also use the special strings &ldquo;localhost&rdquo; or &ldquo;loopback&rdquo; to specify that
the socket only accept connections from the local machine.</p>

<p>To accept connections on any interface pass nil, or simply use the <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectToHost:onPort:error:" title="connectToHost:onPort:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectToHost:onPort:error:">&ndash;&nbsp;connectToHost:onPort:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Connects to the given host and port.
The host may be a domain name (e.g. &ldquo;deusty.com&rdquo;) or an IP address string (e.g. &ldquo;192.168.0.2&rdquo;)</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>hostname</em> onPort:(UInt16)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Connects to the given host and port.
The host may be a domain name (e.g. &ldquo;deusty.com&rdquo;) or an IP address string (e.g. &ldquo;192.168.0.2&rdquo;)</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectToHost:onPort:withTimeout:error:" title="connectToHost:onPort:withTimeout:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectToHost:onPort:withTimeout:error:">&ndash;&nbsp;connectToHost:onPort:withTimeout:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method is the same as <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> with an additional timeout option.
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> method.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>hostname</em> onPort:(UInt16)<em>port</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method is the same as <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> with an additional timeout option.
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectToAddress:error:" title="connectToAddress:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectToAddress:error:">&ndash;&nbsp;connectToAddress:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Connects to the given address, specified as a sockaddr structure wrapped in a NSData object.
For example, a NSData object returned from NSNetService&rsquo;s addresses method.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Connects to the given address, specified as a sockaddr structure wrapped in a NSData object.
For example, a NSData object returned from NSNetService&rsquo;s addresses method.</p>

<p>If you have an existing struct sockaddr you can convert it to a NSData object like so:
struct sockaddr sa  -> NSData <em>dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len];
struct sockaddr </em>sa -> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectToAddress:withTimeout:error:" title="connectToAddress:withTimeout:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectToAddress:withTimeout:error:">&ndash;&nbsp;connectToAddress:withTimeout:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method is the same as <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> with an additional timeout option.
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> method.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method is the same as <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> with an additional timeout option.
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> method.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectToAddress:viaInterfaceAddress:withTimeout:error:" title="connectToAddress:viaInterfaceAddress:withTimeout:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectToAddress:viaInterfaceAddress:withTimeout:error:">&ndash;&nbsp;connectToAddress:viaInterfaceAddress:withTimeout:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method is similar to the one above, but allows you to specify which socket interface
the connection should run over. E.g. ethernet, wifi, bluetooth, etc.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> viaInterfaceAddress:(NSData *)<em>interfaceAddr</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method is similar to the one above, but allows you to specify which socket interface
the connection should run over. E.g. ethernet, wifi, bluetooth, etc.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/disconnect" title="disconnect"></a>
	<h3 class="method-title"><code><a href="#//api/name/disconnect">&ndash;&nbsp;disconnect</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Disconnects immediately. Any pending reads or writes are dropped.
If the socket is not already disconnected, the onSocketDidDisconnect <a href="#//api/name/delegate">delegate</a> method
will be called immediately, before this method returns.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)disconnect</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Disconnects immediately. Any pending reads or writes are dropped.
If the socket is not already disconnected, the onSocketDidDisconnect delegate method
will be called immediately, before this method returns.</p>

<p>Please note the recommended way of releasing an AsyncSocket instance (e.g. in a dealloc method)
[asyncSocket setDelegate:nil];
[asyncSocket disconnect];
[asyncSocket release];</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/disconnectAfterReading" title="disconnectAfterReading"></a>
	<h3 class="method-title"><code><a href="#//api/name/disconnectAfterReading">&ndash;&nbsp;disconnectAfterReading</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Disconnects after all pending reads have completed.
After calling this, the read and write methods will do nothing.
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending writes.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)disconnectAfterReading</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Disconnects after all pending reads have completed.
After calling this, the read and write methods will do nothing.
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending writes.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/disconnectAfterWriting" title="disconnectAfterWriting"></a>
	<h3 class="method-title"><code><a href="#//api/name/disconnectAfterWriting">&ndash;&nbsp;disconnectAfterWriting</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Disconnects after all pending writes have completed.
After calling this, the read and write methods will do nothing.
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending reads.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)disconnectAfterWriting</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Disconnects after all pending writes have completed.
After calling this, the read and write methods will do nothing.
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending reads.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/disconnectAfterReadingAndWriting" title="disconnectAfterReadingAndWriting"></a>
	<h3 class="method-title"><code><a href="#//api/name/disconnectAfterReadingAndWriting">&ndash;&nbsp;disconnectAfterReadingAndWriting</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Disconnects after all pending reads and writes have completed.
After calling this, the read and write methods will do nothing.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)disconnectAfterReadingAndWriting</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Disconnects after all pending reads and writes have completed.
After calling this, the read and write methods will do nothing.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectedHost" title="connectedHost"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectedHost">&ndash;&nbsp;connectedHost</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected.
The host will be an IP address.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSString *)connectedHost</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected.
The host will be an IP address.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/connectedAddress" title="connectedAddress"></a>
	<h3 class="method-title"><code><a href="#//api/name/connectedAddress">&ndash;&nbsp;connectedAddress</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns the local or remote address to which this socket is connected,
specified as a sockaddr structure wrapped in a NSData object.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSData *)connectedAddress</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns the local or remote address to which this socket is connected,
specified as a sockaddr structure wrapped in a NSData object.</p>

<p>See also the <a href="#//api/name/connectedHost">connectedHost</a>, connectedPort, localHost and localPort methods.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/isIPv4" title="isIPv4"></a>
	<h3 class="method-title"><code><a href="#//api/name/isIPv4">&ndash;&nbsp;isIPv4</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns whether the socket is IPv4 or IPv6.
An accepting socket may be both.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns whether the socket is IPv4 or IPv6.
An accepting socket may be both.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readDataWithTimeout:tag:" title="readDataWithTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/readDataWithTimeout:tag:">&ndash;&nbsp;readDataWithTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Reads the first available bytes that become available on the socket.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)readDataWithTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Reads the first available bytes that become available on the socket.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readDataWithTimeout:buffer:bufferOffset:tag:" title="readDataWithTimeout:buffer:bufferOffset:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/readDataWithTimeout:buffer:bufferOffset:tag:">&ndash;&nbsp;readDataWithTimeout:buffer:bufferOffset:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Reads the first available bytes that become available on the socket.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)readDataWithTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Reads the first available bytes that become available on the socket.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.
If the buffer if nil, the socket will create a buffer for you.</p>

<p>If the bufferOffset is greater than the length of the given buffer,
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it.
After completion, the data returned in onSocket:didReadData:withTag: will be a subset of the given buffer.
That is, it will reference the bytes that were appended to the given buffer.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:" title="readDataWithTimeout:buffer:bufferOffset:maxLength:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:">&ndash;&nbsp;readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Reads the first available bytes that become available on the socket.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.
A maximum of length bytes will be read.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)readDataWithTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> maxLength:(NSUInteger)<em>length</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Reads the first available bytes that become available on the socket.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.
A maximum of length bytes will be read.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.
If the buffer if nil, a buffer will automatically be created for you.
If maxLength is zero, no length restriction is enforced.</p>

<p>If the bufferOffset is greater than the length of the given buffer,
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it.
After completion, the data returned in onSocket:didReadData:withTag: will be a subset of the given buffer.
That is, it will reference the bytes that were appended to the given buffer.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readDataToLength:withTimeout:tag:" title="readDataToLength:withTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/readDataToLength:withTimeout:tag:">&ndash;&nbsp;readDataToLength:withTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Reads the given number of bytes.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)readDataToLength:(NSUInteger)<em>length</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Reads the given number of bytes.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.</p>

<p>If the length is 0, this method does nothing and the <a href="#//api/name/delegate">delegate</a> is not called.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:" title="readDataToLength:withTimeout:buffer:bufferOffset:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:">&ndash;&nbsp;readDataToLength:withTimeout:buffer:bufferOffset:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Reads the given number of bytes.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)readDataToLength:(NSUInteger)<em>length</em> withTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Reads the given number of bytes.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.
If the buffer if nil, a buffer will automatically be created for you.</p>

<p>If the length is 0, this method does nothing and the <a href="#//api/name/delegate">delegate</a> is not called.
If the bufferOffset is greater than the length of the given buffer,
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it.
After completion, the data returned in onSocket:didReadData:withTag: will be a subset of the given buffer.
That is, it will reference the bytes that were appended to the given buffer.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:tag:" title="readDataToData:withTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/readDataToData:withTimeout:tag:">&ndash;&nbsp;readDataToData:withTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.</p>

<p>If you pass nil or zero-length data as the &ldquo;data&rdquo; parameter,
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the &ldquo;data&rdquo; parameter.
Note that this method is not character-set aware, so if a separator can occur naturally as part of the encoding for
a character, the read will prematurely end.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:" title="readDataToData:withTimeout:buffer:bufferOffset:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:">&ndash;&nbsp;readDataToData:withTimeout:buffer:bufferOffset:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.
If the buffer if nil, a buffer will automatically be created for you.</p>

<p>If the bufferOffset is greater than the length of the given buffer,
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it.
After completion, the data returned in onSocket:didReadData:withTag: will be a subset of the given buffer.
That is, it will reference the bytes that were appended to the given buffer.</p>

<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the &ldquo;data&rdquo; parameter.
Note that this method is not character-set aware, so if a separator can occur naturally as part of the encoding for
a character, the read will prematurely end.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:maxLength:tag:" title="readDataToData:withTimeout:maxLength:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/readDataToData:withTimeout:maxLength:tag:">&ndash;&nbsp;readDataToData:withTimeout:maxLength:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> maxLength:(NSUInteger)<em>length</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.</p>

<p>If maxLength is zero, no length restriction is enforced.
Otherwise if maxLength bytes are read without completing the read,
it is treated similarly to a timeout - the socket is closed with a AsyncSocketReadMaxedOutError.
The read will complete successfully if exactly maxLength bytes are read and the given data is found at the end.</p>

<p>If you pass nil or zero-length data as the &ldquo;data&rdquo; parameter,
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.
If you pass a maxLength parameter that is less than the length of the data parameter,
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the &ldquo;data&rdquo; parameter.
Note that this method is not character-set aware, so if a separator can occur naturally as part of the encoding for
a character, the read will prematurely end.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:" title="readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:">&ndash;&nbsp;readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.
A maximum of length bytes will be read.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> maxLength:(NSUInteger)<em>length</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.
A maximum of length bytes will be read.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.
If the buffer if nil, a buffer will automatically be created for you.</p>

<p>If maxLength is zero, no length restriction is enforced.
Otherwise if maxLength bytes are read without completing the read,
it is treated similarly to a timeout - the socket is closed with a AsyncSocketReadMaxedOutError.
The read will complete successfully if exactly maxLength bytes are read and the given data is found at the end.</p>

<p>If you pass a maxLength parameter that is less than the length of the data parameter,
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.
If the bufferOffset is greater than the length of the given buffer,
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it.
After completion, the data returned in onSocket:didReadData:withTag: will be a subset of the given buffer.
That is, it will reference the bytes that were appended to the given buffer.</p>

<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the &ldquo;data&rdquo; parameter.
Note that this method is not character-set aware, so if a separator can occur naturally as part of the encoding for
a character, the read will prematurely end.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/writeData:withTimeout:tag:" title="writeData:withTimeout:tag:"></a>
	<h3 class="method-title"><code><a href="#//api/name/writeData:withTimeout:tag:">&ndash;&nbsp;writeData:withTimeout:tag:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Writes data to the socket, and calls the <a href="#//api/name/delegate">delegate</a> when finished.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)writeData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Writes data to the socket, and calls the <a href="#//api/name/delegate">delegate</a> when finished.</p>

<p>If you pass in nil or zero-length data, this method does nothing and the <a href="#//api/name/delegate">delegate</a> will not be called.
If the timeout value is negative, the write operation will not use a timeout.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/progressOfReadReturningTag:bytesDone:total:" title="progressOfReadReturningTag:bytesDone:total:"></a>
	<h3 class="method-title"><code><a href="#//api/name/progressOfReadReturningTag:bytesDone:total:">&ndash;&nbsp;progressOfReadReturningTag:bytesDone:total:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns progress of current read or write, from 0.0 to 1.0, or NaN if no read/write (use isnan() to check).
&ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (float)progressOfReadReturningTag:(long *)<em>tag</em> bytesDone:(NSUInteger *)<em>done</em> total:(NSUInteger *)<em>total</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns progress of current read or write, from 0.0 to 1.0, or NaN if no read/write (use isnan() to check).
&ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/startTLS:" title="startTLS:"></a>
	<h3 class="method-title"><code><a href="#//api/name/startTLS:">&ndash;&nbsp;startTLS:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Secures the connection using SSL/TLS.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)startTLS:(NSDictionary *)<em>tlsSettings</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Secures the connection using SSL/TLS.</p>

<p>This method may be called at any time, and the TLS handshake will occur after all pending reads and writes
are finished. This allows one the option of sending a protocol dependent StartTLS message, and queuing
the upgrade to TLS at the same time, without having to wait for the write to finish.
Any reads or writes scheduled after this method is called will occur over the secured connection.</p>

<p>The possible keys and values for the TLS settings are well documented.
Some possible keys are:
- kCFStreamSSLLevel
- kCFStreamSSLAllowsExpiredCertificates
- kCFStreamSSLAllowsExpiredRoots
- kCFStreamSSLAllowsAnyRoot
- kCFStreamSSLValidatesCertificateChain
- kCFStreamSSLPeerName
- kCFStreamSSLCertificates
- kCFStreamSSLIsServer</p>

<p>Please refer to Apple&rsquo;s documentation for associated values, as well as other possible keys.</p>

<p>If you pass in nil or an empty dictionary, the default settings will be used.</p>

<p>The default settings will check to make sure the remote party&rsquo;s certificate is signed by a
trusted 3rd party certificate agency (e.g. verisign) and that the certificate is not expired.
However it will not verify the name on the certificate unless you
give it a name to verify against via the kCFStreamSSLPeerName key.
The security implications of this are important to understand.
Imagine you are attempting to create a secure connection to MySecureServer.com,
but your socket gets directed to MaliciousServer.com because of a hacked DNS server.
If you simply use the default settings, and MaliciousServer.com has a valid certificate,
the default settings will not detect any problems since the certificate is valid.
To properly secure your connection in this particular scenario you
should set the kCFStreamSSLPeerName property to &ldquo;MySecureServer.com&rdquo;.
If you do not know the peer name of the remote host in advance (for example, you&rsquo;re not sure
if it will be &ldquo;domain.com&rdquo; or &ldquo;www.domain.com&rdquo;), then you can use the default settings to validate the
certificate, and then use the X509Certificate class to verify the issuer after the socket has been secured.
The X509Certificate class is part of the CocoaAsyncSocket open source project.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/enablePreBuffering" title="enablePreBuffering"></a>
	<h3 class="method-title"><code><a href="#//api/name/enablePreBuffering">&ndash;&nbsp;enablePreBuffering</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>For handling readDataToData requests, data is necessarily read from the socket in small increments.
The performance can be much improved by allowing AsyncSocket to read larger chunks at a time and
store any overflow in a small internal buffer.
This is termed pre-buffering, as some data may be read for you before you ask for it.
If you use readDataToData a lot, enabling pre-buffering will result in better performance, especially on the iPhone.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)enablePreBuffering</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>For handling readDataToData requests, data is necessarily read from the socket in small increments.
The performance can be much improved by allowing AsyncSocket to read larger chunks at a time and
store any overflow in a small internal buffer.
This is termed pre-buffering, as some data may be read for you before you ask for it.
If you use readDataToData a lot, enabling pre-buffering will result in better performance, especially on the iPhone.</p>

<p>The default pre-buffering state is controlled by the DEFAULT_PREBUFFERING definition.
It is highly recommended one leave this set to YES.</p>

<p>This method exists in case pre-buffering needs to be disabled by default for some unforeseen reason.
In that case, this method exists to allow one to easily enable pre-buffering when ready.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/moveToRunLoop:" title="moveToRunLoop:"></a>
	<h3 class="method-title"><code><a href="#//api/name/moveToRunLoop:">&ndash;&nbsp;moveToRunLoop:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>When you create an AsyncSocket, it is added to the runloop of the current thread.
So for manually created sockets, it is easiest to simply create the socket on the thread you intend to use it.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)moveToRunLoop:(NSRunLoop *)<em>runLoop</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>When you create an AsyncSocket, it is added to the runloop of the current thread.
So for manually created sockets, it is easiest to simply create the socket on the thread you intend to use it.</p>

<p>If a new socket is accepted, the <a href="#//api/name/delegate">delegate</a> method onSocket:wantsRunLoopForNewSocket: is called to
allow you to place the socket on a separate thread. This works best in conjunction with a thread pool design.</p>

<p>If, however, you need to move the socket to a separate thread at a later time, this
method may be used to accomplish the task.</p>

<p>This method must be called from the thread/runloop the socket is currently running on.</p>

<p>Note: After calling this method, all further method calls to this object should be done from the given runloop.
Also, all <a href="#//api/name/delegate">delegate</a> calls will be sent on the given runloop.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/setRunLoopModes:" title="setRunLoopModes:"></a>
	<h3 class="method-title"><code><a href="#//api/name/setRunLoopModes:">&ndash;&nbsp;setRunLoopModes:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Allows you to configure which run loop modes the socket uses.
The default set of run loop modes is NSDefaultRunLoopMode.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)setRunLoopModes:(NSArray *)<em>runLoopModes</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Allows you to configure which run loop modes the socket uses.
The default set of run loop modes is NSDefaultRunLoopMode.</p>

<p>If you&rsquo;d like your socket to continue operation during other modes, you may want to add modes such as
NSModalPanelRunLoopMode or NSEventTrackingRunLoopMode. Or you may simply want to use NSRunLoopCommonModes.</p>

<p>Accepted sockets will automatically inherit the same run loop modes as the listening socket.</p>

<p>Note: NSRunLoopCommonModes is defined in 10.5. For previous versions one can use kCFRunLoopCommonModes.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/runLoopModes" title="runLoopModes"></a>
	<h3 class="method-title"><code><a href="#//api/name/runLoopModes">&ndash;&nbsp;runLoopModes</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns the current run loop modes the AsyncSocket instance is operating in.
The default set of run loop modes is NSDefaultRunLoopMode.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSArray *)runLoopModes</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns the current run loop modes the AsyncSocket instance is operating in.
The default set of run loop modes is NSDefaultRunLoopMode.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/unreadData" title="unreadData"></a>
	<h3 class="method-title"><code><a href="#//api/name/unreadData">&ndash;&nbsp;unreadData</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>In the event of an error, this method may be called during onSocket:willDisconnectWithError: to read
any data that&rsquo;s left on the socket.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSData *)unreadData</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>In the event of an error, this method may be called during onSocket:willDisconnectWithError: to read
any data that&rsquo;s left on the socket.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						
						<h2 class="task-title">Other Methods</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/newAcceptSocketForAddress:error:" title="newAcceptSocketForAddress:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/newAcceptSocketForAddress:error:">&ndash;&nbsp;newAcceptSocketForAddress:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Creates the accept sockets.
Returns true if either IPv4 or IPv6 is created.
If either is missing, an error is returned (even though the method may return true).</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (CFSocketRef)newAcceptSocketForAddress:(NSData *)<em>addr</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Creates the accept sockets.
Returns true if either IPv4 or IPv6 is created.
If either is missing, an error is returned (even though the method may return true).</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/attachSocketsToRunLoop:error:" title="attachSocketsToRunLoop:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/attachSocketsToRunLoop:error:">&ndash;&nbsp;attachSocketsToRunLoop:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Adds the CFSocket&rsquo;s to the run-loop so that callbacks will work properly.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)attachSocketsToRunLoop:(NSRunLoop *)<em>runLoop</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Adds the CFSocket&rsquo;s to the run-loop so that callbacks will work properly.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/configureSocketAndReturnError:" title="configureSocketAndReturnError:"></a>
	<h3 class="method-title"><code><a href="#//api/name/configureSocketAndReturnError:">&ndash;&nbsp;configureSocketAndReturnError:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Allows the <a href="#//api/name/delegate">delegate</a> method to configure the CFSocket or CFNativeSocket as desired before we connect.
Note that the CFReadStream and CFWriteStream will not be available until after the connection is opened.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)configureSocketAndReturnError:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Allows the <a href="#//api/name/delegate">delegate</a> method to configure the CFSocket or CFNativeSocket as desired before we connect.
Note that the CFReadStream and CFWriteStream will not be available until after the connection is opened.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doAcceptFromSocket:withNewNativeSocket:" title="doAcceptFromSocket:withNewNativeSocket:"></a>
	<h3 class="method-title"><code><a href="#//api/name/doAcceptFromSocket:withNewNativeSocket:">&ndash;&nbsp;doAcceptFromSocket:withNewNativeSocket:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Attempt to make the new socket.
If an error occurs, ignore this event.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doAcceptFromSocket:(CFSocketRef)<em>parentSocket</em> withNewNativeSocket:(CFSocketNativeHandle)<em>newNativeSocket</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Attempt to make the new socket.
If an error occurs, ignore this event.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doSocketOpen:withCFSocketError:" title="doSocketOpen:withCFSocketError:"></a>
	<h3 class="method-title"><code><a href="#//api/name/doSocketOpen:withCFSocketError:">&ndash;&nbsp;doSocketOpen:withCFSocketError:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method is called as a result of <a href="#//api/name/connectToAddress:withTimeout:error:">connectToAddress:withTimeout:error:</a>.
At this point we have an open CFSocket from which we need to create our read and write stream.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doSocketOpen:(CFSocketRef)<em>sock</em> withCFSocketError:(CFSocketError)<em>socketError</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method is called as a result of <a href="#//api/name/connectToAddress:withTimeout:error:">connectToAddress:withTimeout:error:</a>.
At this point we have an open CFSocket from which we need to create our read and write stream.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/createStreamsFromNative:error:" title="createStreamsFromNative:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/createStreamsFromNative:error:">&ndash;&nbsp;createStreamsFromNative:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Creates the CFReadStream and CFWriteStream from the given native socket.
The CFSocket may be extracted from either stream after the streams have been opened.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)createStreamsFromNative:(CFSocketNativeHandle)<em>native</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Creates the CFReadStream and CFWriteStream from the given native socket.
The CFSocket may be extracted from either stream after the streams have been opened.</p>

<p>Note: The given native socket must already be connected!</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/createStreamsToHost:onPort:error:" title="createStreamsToHost:onPort:error:"></a>
	<h3 class="method-title"><code><a href="#//api/name/createStreamsToHost:onPort:error:">&ndash;&nbsp;createStreamsToHost:onPort:error:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Creates the CFReadStream and CFWriteStream from the given hostname and port number.
The CFSocket may be extracted from either stream after the streams have been opened.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)createStreamsToHost:(NSString *)<em>hostname</em> onPort:(UInt16)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Creates the CFReadStream and CFWriteStream from the given hostname and port number.
The CFSocket may be extracted from either stream after the streams have been opened.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/configureStreamsAndReturnError:" title="configureStreamsAndReturnError:"></a>
	<h3 class="method-title"><code><a href="#//api/name/configureStreamsAndReturnError:">&ndash;&nbsp;configureStreamsAndReturnError:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Allows the <a href="#//api/name/delegate">delegate</a> method to configure the CFReadStream and/or CFWriteStream as desired before we connect.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)configureStreamsAndReturnError:(NSError **)<em>errPtr</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Allows the <a href="#//api/name/delegate">delegate</a> method to configure the CFReadStream and/or CFWriteStream as desired before we connect.</p>

<p>If being called from a connect method,
the CFSocket and CFNativeSocket will not be available until after the connection is opened.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doStreamOpen" title="doStreamOpen"></a>
	<h3 class="method-title"><code><a href="#//api/name/doStreamOpen">&ndash;&nbsp;doStreamOpen</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Called when read or write streams open.
When the socket is connected and both streams are open, consider the AsyncSocket instance to be ready.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doStreamOpen</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Called when read or write streams open.
When the socket is connected and both streams are open, consider the AsyncSocket instance to be ready.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/close" title="close"></a>
	<h3 class="method-title"><code><a href="#//api/name/close">&ndash;&nbsp;close</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Disconnects. This is called for both error and clean disconnections.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)close</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Disconnects. This is called for both error and clean disconnections.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/maybeScheduleDisconnect" title="maybeScheduleDisconnect"></a>
	<h3 class="method-title"><code><a href="#//api/name/maybeScheduleDisconnect">&ndash;&nbsp;maybeScheduleDisconnect</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Schedules a call to <a href="#//api/name/disconnect">disconnect</a> if possible.
That is, if all writes have completed, and we&rsquo;re set to <a href="#//api/name/disconnect">disconnect</a> after writing,
or if all reads have completed, and we&rsquo;re set to <a href="#//api/name/disconnect">disconnect</a> after reading.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)maybeScheduleDisconnect</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Schedules a call to <a href="#//api/name/disconnect">disconnect</a> if possible.
That is, if all writes have completed, and we&rsquo;re set to <a href="#//api/name/disconnect">disconnect</a> after writing,
or if all reads have completed, and we&rsquo;re set to <a href="#//api/name/disconnect">disconnect</a> after reading.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getErrnoError" title="getErrnoError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getErrnoError">&ndash;&nbsp;getErrnoError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard error object for the current errno value.
Errno is used for low-level BSD socket errors.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getErrnoError</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns a standard error object for the current errno value.
Errno is used for low-level BSD socket errors.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getSocketError" title="getSocketError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getSocketError">&ndash;&nbsp;getSocketError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard error message for a CFSocket error.
Unfortunately, CFSocket offers no feedback on its errors.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getSocketError</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns a standard error message for a CFSocket error.
Unfortunately, CFSocket offers no feedback on its errors.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getAbortError" title="getAbortError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getAbortError">&ndash;&nbsp;getAbortError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard AsyncSocket abort error.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getAbortError</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns a standard AsyncSocket abort error.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getConnectTimeoutError" title="getConnectTimeoutError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getConnectTimeoutError">&ndash;&nbsp;getConnectTimeoutError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard AsyncSocket connect timeout error.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getConnectTimeoutError</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns a standard AsyncSocket connect timeout error.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getReadMaxedOutError" title="getReadMaxedOutError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getReadMaxedOutError">&ndash;&nbsp;getReadMaxedOutError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard AsyncSocket maxed out error.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getReadMaxedOutError</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns a standard AsyncSocket maxed out error.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getReadTimeoutError" title="getReadTimeoutError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getReadTimeoutError">&ndash;&nbsp;getReadTimeoutError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard AsyncSocket read timeout error.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getReadTimeoutError</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns a standard AsyncSocket read timeout error.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/getWriteTimeoutError" title="getWriteTimeoutError"></a>
	<h3 class="method-title"><code><a href="#//api/name/getWriteTimeoutError">&ndash;&nbsp;getWriteTimeoutError</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Returns a standard AsyncSocket write timeout error.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (NSError *)getWriteTimeoutError</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Returns a standard AsyncSocket write timeout error.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/scheduleDequeueRead" title="scheduleDequeueRead"></a>
	<h3 class="method-title"><code><a href="#//api/name/scheduleDequeueRead">&ndash;&nbsp;scheduleDequeueRead</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Puts a <a href="#//api/name/maybeDequeueRead">maybeDequeueRead</a> on the run loop.
An assumption here is that selectors will be performed consecutively within their priority.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)scheduleDequeueRead</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Puts a <a href="#//api/name/maybeDequeueRead">maybeDequeueRead</a> on the run loop.
An assumption here is that selectors will be performed consecutively within their priority.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/maybeDequeueRead" title="maybeDequeueRead"></a>
	<h3 class="method-title"><code><a href="#//api/name/maybeDequeueRead">&ndash;&nbsp;maybeDequeueRead</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method starts a new read, if needed.
It is called when a user requests a read,
or when a stream opens that may have requested reads sitting in the queue, etc.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)maybeDequeueRead</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method starts a new read, if needed.
It is called when a user requests a read,
or when a stream opens that may have requested reads sitting in the queue, etc.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/hasBytesAvailable" title="hasBytesAvailable"></a>
	<h3 class="method-title"><code><a href="#//api/name/hasBytesAvailable">&ndash;&nbsp;hasBytesAvailable</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Call this method in <a href="#//api/name/doBytesAvailable">doBytesAvailable</a> instead of CFReadStreamHasBytesAvailable().
This method supports pre-buffering properly as well as the kSocketHasBytesAvailable flag.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)hasBytesAvailable</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Call this method in <a href="#//api/name/doBytesAvailable">doBytesAvailable</a> instead of CFReadStreamHasBytesAvailable().
This method supports pre-buffering properly as well as the kSocketHasBytesAvailable flag.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readIntoBuffer:maxLength:" title="readIntoBuffer:maxLength:"></a>
	<h3 class="method-title"><code><a href="#//api/name/readIntoBuffer:maxLength:">&ndash;&nbsp;readIntoBuffer:maxLength:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Call this method in <a href="#//api/name/doBytesAvailable">doBytesAvailable</a> instead of CFReadStreamRead().
This method support pre-buffering properly.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (CFIndex)readIntoBuffer:(void *)<em>buffer</em> maxLength:(NSUInteger)<em>length</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Call this method in <a href="#//api/name/doBytesAvailable">doBytesAvailable</a> instead of CFReadStreamRead().
This method support pre-buffering properly.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/doBytesAvailable" title="doBytesAvailable"></a>
	<h3 class="method-title"><code><a href="#//api/name/doBytesAvailable">&ndash;&nbsp;doBytesAvailable</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>This method is called when a new read is taken from the read queue or when new data becomes available on the stream.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)doBytesAvailable</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>This method is called when a new read is taken from the read queue or when new data becomes available on the stream.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/maybeDequeueWrite" title="maybeDequeueWrite"></a>
	<h3 class="method-title"><code><a href="#//api/name/maybeDequeueWrite">&ndash;&nbsp;maybeDequeueWrite</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Conditionally starts a new write.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)maybeDequeueWrite</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Conditionally starts a new write.</p>

<p>IF there is not another write in process
AND there is a write queued
AND we have a write stream available</p>

<p>This method also handles auto<a href="#//api/name/disconnect">disconnect</a> post read/write completion.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/canAcceptBytes" title="canAcceptBytes"></a>
	<h3 class="method-title"><code><a href="#//api/name/canAcceptBytes">&ndash;&nbsp;canAcceptBytes</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Call this method in <a href="#//api/name/doSendBytes">doSendBytes</a> instead of CFWriteStreamCanAcceptBytes().
This method supports the kSocketCanAcceptBytes flag.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)canAcceptBytes</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>Call this method in <a href="#//api/name/doSendBytes">doSendBytes</a> instead of CFWriteStreamCanAcceptBytes().
This method supports the kSocketCanAcceptBytes flag.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AsyncSocket.m</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						
					</div>
					
					

                    
                    
          
				</main>

				<footer>
					<div class="footer-copyright">
						
						<p class="copyright">Copyright &copy; 2016 AWARE. All rights reserved. Updated: 2016-04-16</p>
						
						
						<p class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.2.1 (build 1334)</a>.</p>
						
					</div>
				</footer>
			</div>
		</div>
	</article>

	<script src="../js/script.js"></script>
</body>
</html>